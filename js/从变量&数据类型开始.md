## 
* var 声明的作用域是函数的作用域，存在变量提升，在声明之前调用值会为undefined，可以重复声明
### es6
* const 声明的属性是只读属性，不允许修改。声明的变量不允许修改，重新赋值会报错
* let 属于在相应块中声明的块作用域，不存在变量提升，在声明之前调用报错，重复声明报错


# 全局变量 与 隐式全局变量、局部变量
* 在函数内的没有用var或let声明的变量是隐式全局变量。
* 用var操作符定义的变量将成为定义该变量的作用域中的局部变量，在函数退出后就会被销毁。


## 内存和作用域
 * + 基本类型和引用类型
   - 基本类型是指简单的数据段 栈内存中 在内存中在固定的大小
   - 引用类型值是指那些可能由多个值构成的对象，是保存在内存中的对象  堆内存中
   - js不允许直接访问内存的位置 所以不是直接访问对象 引用类型实际上是按引用访问
   - 基本类型 从一个变量复制为另一个变量 ，会复制这个值的副本；
   - 复制引用类型的值 复制的实际上指针 ， 因此两个变量最终都指向同一个对象；


## 作用域 
 所有变量都存在于一个执行环境中，执行环境也称为作用域，执行环境决定了变量的 生命周期。
 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。p73
### 作用域链：
 * 代码在一个执行中会创建变量对象的一个作用域链。作用 ：保证对执行环境有权访问的所有变量和函数的有序访问。
### 延长作用域链
* try{}catch(){}中的catch块
* with
这两个语句都会在作用域的前端添加一个变量对象/
## 块级作用域
* 没有块级作用域的时候，if 语句中定义的变量或for语句初始化变量的表达式所定义的变量i在循环结束后依旧访问。在有块级作用域中执行完if或for语句时就会销毁变量了，语句外访问不了这个变量。






## 思考：es6 之前块级作用域的实现 
 
### 思路：闭包 和 立即执行函数
  1.(function(num){return num;})(x)
  2.function ff(num){ return num}  ff(x);


